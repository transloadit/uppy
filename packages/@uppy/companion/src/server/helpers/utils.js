const crypto = require('node:crypto')

const nonceLength = 16
const encryptionKeyLength = 32
const ivLength = 12

/**
 *
 * @param {string} value
 * @param {string[]} criteria
 * @returns {boolean}
 */
exports.hasMatch = (value, criteria) => {
  return criteria.some((i) => {
    return value === i || (new RegExp(i)).test(value)
  })
}

/**
 *
 * @param {object} data
 * @returns {string}
 */
exports.jsonStringify = (data) => {
  const cache = []
  return JSON.stringify(data, (key, value) => {
    if (typeof value === 'object' && value !== null) {
      if (cache.indexOf(value) !== -1) {
        // Circular reference found, discard key
        return undefined
      }
      cache.push(value)
    }
    return value
  })
}

// all paths are assumed to be '/' prepended
/**
 * Returns a url builder
 *
 * @param {object} options companion options
 */
module.exports.getURLBuilder = (options) => {
  /**
   * Builds companion targeted url
   *
   * @param {string} subPath the tail path of the url
   * @param {boolean} isExternal if the url is for the external world
   * @param {boolean} [excludeHost] if the server domain and protocol should be included
   */
  const buildURL = (subPath, isExternal, excludeHost) => {
    let path = ''

    if (isExternal && options.server.implicitPath) {
      path += options.server.implicitPath
    }

    if (options.server.path) {
      path += options.server.path
    }

    path += subPath

    if (excludeHost) {
      return path
    }

    return `${options.server.protocol}://${options.server.host}${path}`
  }

  return buildURL
}

/**
 * Create an AES-CCM encryption key and initialization vector from the provided secret
 * and a random nonce. The nonce can either be provided as parameter or generated by The
 * function if the parameter is null
 *
 * @param {string|Buffer} secret
 * @param {Buffer|undefined} nonce
 */
function createSecrets(secret, nonce) {
  let actualNonce = nonce
  if (actualNonce === undefined) {
    actualNonce = crypto.randomBytes(nonceLength)
  }
  const keyOut = crypto.hkdfSync('sha256', secret, new Uint8Array(32), actualNonce, encryptionKeyLength + ivLength)
  const buf = Buffer.from(keyOut)
  return [
    actualNonce,
    buf.subarray(0, encryptionKeyLength),
    buf.subarray(encryptionKeyLength, encryptionKeyLength + ivLength)
  ]
}

/**
 * Encrypt a buffer or string with AES256 and a random iv.
 *
 * @param {string} input
 * @param {string|Buffer} secret
 * @returns {string} Ciphertext as a hex string, prefixed with 32 hex characters containing the iv.
 */
module.exports.encrypt = (input, secret) => {
  const [nonce, key, iv] = createSecrets(secret, undefined)
  const cipher = crypto.createCipheriv('aes-256-ccm', key, iv, {authTagLength: 16})
  let encrypted = cipher.update(input, 'utf8', 'base64url')
  encrypted += cipher.final('base64url')
  encrypted += cipher.getAuthTag().toString('base64url')
  // add iv to encrypted string to use for decryption
  return nonce.toString('hex') + encrypted
}

/**
 * Decrypt an iv-prefixed or string with AES256. The iv should be in the first 32 hex characters.
 *
 * @param {string} encrypted
 * @param {string|Buffer} secret
 * @returns {string} Decrypted value.
 */
module.exports.decrypt = (encrypted, secret) => {
  // Need at least 32 chars for the iv
  if (encrypted.length < nonceLength*2) {
    throw new Error('Invalid encrypted value. Maybe it was generated with an old Companion version?')
  }

  // NOTE: The first 32 characters are the nonce, in hex format. The rest is the encrypted string, in base64 format.
  const nonce = Buffer.from(encrypted.slice(0, nonceLength*2), 'hex')
  const encryptionWithoutNonce = encrypted.slice(nonceLength*2)

  const [, key, iv] = createSecrets(secret, nonce)

  let decipher
  try {
    decipher = crypto.createDecipheriv('aes-256-ccm', key, iv, {authTagLength: 16})
  } catch (err) {
    if (err.code === 'ERR_CRYPTO_INVALID_IV') {
      throw new Error('Invalid initialization vector')
    } else {
      throw err
    }
  }

  // The last 22 bytes of the encrypted data are actually the authentication tag
  // (22 is the base64url size of a 16 bytes value encoded with base64url)
  const encryptionWithoutNonceAndTag = encryptionWithoutNonce.slice(0, encryptionWithoutNonce.length - 22)
  const authTag = encryptionWithoutNonce.slice(encryptionWithoutNonce.length - 22)
  decipher.setAuthTag(Buffer.from(authTag, 'base64url'))
  let decrypted = decipher.update(encryptionWithoutNonceAndTag, 'base64url', 'utf8')
  decrypted += decipher.final('utf8')
  return decrypted
}

module.exports.defaultGetKey = ({ filename }) => `${crypto.randomUUID()}-${filename}`

/**
 * Our own HttpError in cases where we can't use `got`'s `HTTPError`
 */
class HttpError extends Error {
  statusCode

  responseJson

  constructor({ statusCode, responseJson }) {
    super(`Request failed with status ${statusCode}`)
    this.statusCode = statusCode
    this.responseJson = responseJson
    this.name = 'HttpError'
  }
}

module.exports.HttpError = HttpError

module.exports.prepareStream = async (stream) => new Promise((resolve, reject) => {
  stream
    .on('response', (response) => {
      const contentLengthStr = response.headers['content-length']
      const contentLength = parseInt(contentLengthStr, 10);
      const size = !Number.isNaN(contentLength) && contentLength >= 0 ? contentLength : undefined;
      // Don't allow any more data to flow yet.
      // https://github.com/request/request/issues/1990#issuecomment-184712275
      stream.pause()
      resolve({ size })
    })
    .on('error', (err) => {
      // In this case the error object is not a normal GOT HTTPError where json is already parsed,
      // we use our own HttpError error for this scenario.
      if (typeof err.response?.body === 'string' && typeof err.response?.statusCode === 'number') {
        let responseJson
        try {
          responseJson = JSON.parse(err.response.body)
        } catch (err2) {
          reject(err)
          return
        }

        reject(new HttpError({ statusCode: err.response.statusCode, responseJson }))
        return
      }

      reject(err)
    })
})

module.exports.getBasicAuthHeader = (key, secret) => {
  const base64 = Buffer.from(`${key}:${secret}`, 'binary').toString('base64')
  return `Basic ${base64}`
}

const rfc2047Encode = (dataIn) => {
  const data = `${dataIn}`
  // eslint-disable-next-line no-control-regex
  if (/^[\x00-\x7F]*$/.test(data)) return data // we return ASCII as is
  return `=?UTF-8?B?${Buffer.from(data).toString('base64')}?=` // We encode non-ASCII strings
}

module.exports.rfc2047EncodeMetadata = (metadata) => (
  Object.fromEntries(Object.entries(metadata).map((entry) => entry.map(rfc2047Encode)))
)

/**
 *
 * @param {{
 * bucketOrFn: string | ((a: {
 * req: import('express').Request,
 * metadata: Record<string, string>,
 * filename: string | undefined,
 * }) => string),
 * req: import('express').Request,
 * metadata?: Record<string, string>,
 * filename?: string,
 * }} param0
 * @returns
 */
module.exports.getBucket = ({ bucketOrFn, req, metadata, filename }) => {
  const bucket = typeof bucketOrFn === 'function' ? bucketOrFn({ req, metadata, filename }) : bucketOrFn

  if (typeof bucket !== 'string' || bucket === '') {
    // This means a misconfiguration or bug
    throw new TypeError('s3: bucket key must be a string or a function resolving the bucket string')
  }
  return bucket
}
